thread_local使用场景
dre是一个全局的default_random_engine对象（全局对象可以是C风格的extern，也可是C++风格的static，如果在同一个源文件中，则在“代码的上面”）。同时开启多个线程运行，每个线程都需要使用这个全局的dre对象，不同的线程对dre设置不同的seed。但是，又不能让所有线程同时访问同一个dre，这样dre的seed变来变去，而且无法得到想要的随机值序列。

此时有2个解决方案：

改变声明dre的地方，把dre从全局对象变为线程的局部变量（比如一个函数中）。在线程里面，再通过参数的传递，把dre传到需要它的地方。
声明dre的地方不变，依然是全局，只要加一个thread_local关键词，其他什么都不用改。
方案1很丑陋，方案2很优雅。
————————————————
版权声明：本文为CSDN博主「sicolex」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u013390476/article/details/52129607
